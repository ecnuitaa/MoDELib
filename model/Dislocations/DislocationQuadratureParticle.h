/* This file is part of MODEL, the Mechanics Of Defect Evolution Library.
 *
 * Copyright (C) 2011 by Giacomo Po <gpo@ucla.edu>.
 *
 * model is distributed without any warranty under the 
 * GNU General Public License (GPL) v2 <http://www.gnu.org/licenses/>.
 */

#ifndef model_DISLOCATIONQUADRATUREPARTICLE_H_
#define model_DISLOCATIONQUADRATUREPARTICLE_H_

#include <Eigen/Dense>
//#include <model/Quadrature/Quadrature.h>
#include <model/SpaceDecomposition/SpaceCellParticle.h>


namespace model {
	
	/********************************************************************************************/
	/********************************************************************************************/
//	template<short unsigned int dim, double & cellSize, short unsigned int qOrder, template <short unsigned int, short unsigned int> class QuadratureRule = GaussLegendre>
	template<short unsigned int dim, double & cellSize>
	struct DislocationQuadratureParticle : public SpaceCellParticle<DislocationQuadratureParticle<dim,cellSize>,dim,cellSize>{ 

		EIGEN_MAKE_ALIGNED_OPERATOR_NEW

		
#ifdef UserStressFile
#include UserStressFile
#endif
		
		typedef DislocationQuadratureParticle<dim,cellSize> DislocationQuadratureParticleType;
		typedef SpaceCellParticle<DislocationQuadratureParticleType,dim,cellSize> SpaceCellParticleType;		
		//typedef typename SpaceCellParticleType::CellMapType  CellMapType;	
		//typedef typename SpaceCellObserverType::CellMapType  CellMapType;	
		typedef typename SpaceCellParticleType::ParticleContainerType ParticleContainerType;

		typedef typename SpaceCellParticleType::VectorDimD   VectorDimD;	
		typedef typename SpaceCellParticleType::VectorDimI   VectorDimI;	
		typedef Eigen::Matrix<double,dim,dim> MatrixDim;
		
		//! A const reference to Quadrature weight corresponding to this particle 
		const double& quadAbscissa;
		const double& quadWeight;

		//const int k;			// *this is the k-th quadrature point on the segment
		const VectorDimD  P;
		const VectorDimD  T;
		
		//! A const reference to the Burgers vector of the parent DislocationSegment
		const VectorDimD& B;

//		static const double a;
		static const double a2;
		static const double C1;
		static const double C2;
		static const MatrixDim I;
//		NodeType* const source;		
//		NodeType* const sink;
//		const MatrixDim& sourceBvpStress;
//		const MatrixDim&   sinkBvpStress;
		
		/********************************************************/
		DislocationQuadratureParticle(const double& qA,const double& qW,
									  const VectorDimD& Pin, const VectorDimD& Tin, const VectorDimD& Bin) : 
		/* init list */ SpaceCellParticleType::SpaceCellParticle(Pin),
//		/* init list */ k(kin),
		/* init list */ quadAbscissa(qA),
		/* init list */ quadWeight(qW),
		/* init list */ P(Pin),
		/* init list */ T(Tin),
		/* init list */ B(Bin){
//		/* init list */ sourceBvpStress(sourceBvpStress_in),
//		/* init list */ sinkBvpStress(    sinkBvpStress_in){
			
		}
		
		
		
		/********************************************************/
//		template<short unsigned int qOrder, template <short unsigned int, short unsigned int> class QuadratureRule = GaussLegendre>
		MatrixDim stress_at(const VectorDimD& Rfield) const {
			/*! Returns the asymmetric (and dimensionless) part of the stress integrand generated by the current quadrature point.
			 * @param[in] k			the current quadrature point
			 * @param[in] Rfield	the vector connecting source point (corresponding to the current quadrature point) to field point
			 *
			 * The return value is calculated according to:
			 * Cai, W., Arsenlis, A., Weinberger, C., & Bulatov, V. (2006). A non-singular continuum theory of dislocations. Journal Of The Mechanics And Physics Of Solids, 54(3), 561â€“587.
			 *	\f[
			 *		d\mathbf{s} = (1-\nu) \left(1+\frac{3}{2}\frac{a^2}{R_a^2}\right)\frac{\partial \mathbf{r}}{\partial u}\otimes \left(\mathbf{b}\times \mathbf{R}\right)+
			 *		\mathbf{R}\otimes\left(\frac{\partial \mathbf{r}}{\partial u}\times\mathbf{b}\right)+
			 *		\frac{1}{2} \left[ \left(\mathbf{R}\times\mathbf{b}\right)\cdot \frac{\partial \mathbf{r}}{\partial u} \right]\left[\mathbf{I}\left(1+\frac{3a^2}{R_a^2}\right)+\frac{3}{R_a^2}\mathbf{R}\otimes\mathbf{R}\right]
			 *	\f]
			 *  where \f$R_a^2=|\mathbf{R}|^2+a^2\f$ is the modified squared norm of \f$\mathbf{R}\f$.
			 *
			 *	The return value is asymmetric and dimensionless in the sense that the actual stress integrand is:
			 *	\f[
			 *		d\mathbf{\sigma}=\frac{\mu}{4\pi (1-\nu)}\left(d\mathbf{s}+d\mathbf{s}^T\right)
			 *	\f]
			 */
			VectorDimD R(Rfield-P);
			double RaSquared (R.squaredNorm() + a2);
			MatrixDim temp(   (C1*(1.0+1.5*a2/RaSquared)*T*(B.cross(R)).transpose()
					  + 	R*(T.cross(B)).transpose() 
					  +   0.5* R.cross(B).dot(T) * (I*(1.0+3.0*a2/RaSquared) + 3.0/RaSquared*R*R.transpose())
					  )/std::pow(RaSquared,1.5)*quadWeight);
			
			return C2*(temp+temp.transpose());
		}
		


		
		/********************************************************/
		MatrixDim stress() const {
			/*! The total stress field on this DislocationQuadratureParticle
			 */
			MatrixDim temp(MatrixDim::Zero());
			for (typename ParticleContainerType::const_iterator partIter=this->neighborBegin();partIter!=this->neighborEnd();++partIter){
				temp+=(*partIter)->stress_at(P);
			}
			
#ifdef UserStressFile
//			temp+=userStress(k); 
#endif
			
			
			return temp;
		}
		
		/********************************************************/
		MatrixDim stress(const MatrixDim& sourceBvpStress, const MatrixDim& sinkBvpStress) const {
			/*! The total stress field on this DislocationQuadratureParticle
			 */
			MatrixDim temp(MatrixDim::Zero());
			for (typename ParticleContainerType::const_iterator partIter=this->neighborBegin();partIter!=this->neighborEnd();++partIter){
				temp+=(*partIter)->stress_at(P);
			}
			
#ifdef UserStressFile
			//			temp+=userStress(k); 
#endif
			
			temp+=sourceBvpStress*(1.0-quadAbscissa)+sinkBvpStress*quadAbscissa;
			
			return temp;
		}
		
//		/********************************************************/
//		VectorDimD pkForce() const {
//			return (stress()*B).cross(T.normalized());
//		}
		
		
		
	};
	
	
//	template <short unsigned int dim, double & cellSize>
//	const double DislocationQuadratureParticle<dim,cellSize>::a =1.0;

	template <short unsigned int dim, double & cellSize>
	const double DislocationQuadratureParticle<dim,cellSize>::a2=1.0;  // square of core size a

	template <short unsigned int dim, double & cellSize>
	const double DislocationQuadratureParticle<dim,cellSize>::C1=1.0-0.33;  // square of core size a

	template <short unsigned int dim, double & cellSize>
	const double DislocationQuadratureParticle<dim,cellSize>::C2=1.0/(4.0*M_PI*(1.0-0.33));  // square of core size a
	
	template <short unsigned int dim, double & cellSize>
	const Eigen::Matrix<double,dim,dim> DislocationQuadratureParticle<dim,cellSize>::I=Eigen::Matrix<double,dim,dim>::Identity();  // square of core size a
	
	////////////////////////////////////////////////////////////////////////////////
}	// close namespace

#endif
