/* This file is part of MODEL, the Mechanics Of Defect Evolution Library.
 *
 * Copyright (C) 2011 by Giacomo Po <gpo@ucla.edu>.
 *
 * model is distributed without any warranty under the
 * GNU General Public License (GPL) v2 <http://www.gnu.org/licenses/>.
 */

#ifndef _MODEL_DislocationParticle_H_
#define _MODEL_DislocationParticle_H_

#include <Eigen/Dense>
#include <model/SpaceDecomposition/SpatialCellParticle.h>
#include <model/DislocationDynamics/Materials/Material.h>
#include <model/DislocationDynamics/NearestNeighbor/DislocationCell.h>



namespace model {
	
	/********************************************************************************************/
	/********************************************************************************************/
	template<short unsigned int dim>
	struct DislocationParticle :
    /* inheritance */ public SpatialCellParticle<DislocationParticle<dim>,dim>
    {
        
		EIGEN_MAKE_ALIGNED_OPERATOR_NEW
        
#ifdef UserStressFile
#include UserStressFile
#endif
		
		typedef DislocationParticle<dim> DislocationParticleType;
		typedef SpatialCellParticle<DislocationParticleType,dim> SpatialCellParticleType;
		typedef typename SpatialCellParticleType::CellMapType  CellMapType;
		typedef typename SpatialCellParticleType::ParticleContainerType ParticleContainerType;
		typedef typename SpatialCellParticleType::VectorDimD   VectorDimD;
//		typedef typename SpatialCellParticleType::VectorDimI   VectorDimI;
		typedef Eigen::Matrix<double,dim,dim> MatrixDim;
		
		//! A const reference to Quadrature weight corresponding to this particle
		const double& quadAbscissa;
		const double& quadWeight;
        
		//const int k;			// *this is the k-th quadrature point on the segment
		const VectorDimD  P;
		const VectorDimD  T;
		
		//! A const reference to the Burgers vector of the parent DislocationSegment
		const VectorDimD& B;
        
		static  double a2;
		static const MatrixDim I;
        //static bool useMultipoleStress;
        
        enum{FULL=0,CELL_PARTICLE=1,CELL_CELL=2};
        
        static int nearCellStressApproximation;
        static int  farCellStressApproximation;
		
		/********************************************************/
		DislocationParticle(const VectorDimD& Pin, const VectorDimD& Tin, const VectorDimD& Bin,
                            const double& qA,const double& qW) :
		/* base init     */ SpatialCellParticleType::SpatialCellParticle(Pin),
		/* init list     */ quadAbscissa(qA),
		/* init list     */ quadWeight(qW),
		/* init list     */ P(Pin),
		/* init list     */ T(Tin),
		/* init list     */ B(Bin)
        {/*! Constructor updates the alpha-tensor of the cell containing this
          */
            
            //this->pCell->alpha += B * T.transpose() * quadWeight;
            this->pCell->alpha += B * T.transpose() * quadWeight;
		}
		
//		/********************************************************/
//        //		template<short unsigned int qOrder, template <short unsigned int, short unsigned int> class QuadratureRule = GaussLegendre>
//		MatrixDim stress_at(const VectorDimD& Rfield) const
//        {/*! Returns the asymmetric (and dimensionless) part of the stress integrand generated by the current quadrature point.
//          * @param[in] k			the current quadrature point
//          * @param[in] Rfield	the vector connecting source point (corresponding to the current quadrature point) to field point
//          *
//          * The return value is calculated according to:
//          * Cai, W., Arsenlis, A., Weinberger, C., & Bulatov, V. (2006). A non-singular continuum theory of dislocations. Journal Of The Mechanics And Physics Of Solids, 54(3), 561â€“587.
//          *	\f[
//          *		d\mathbf{s} = (1-\nu) \left(1+\frac{3}{2}\frac{a^2}{R_a^2}\right)\frac{\partial \mathbf{r}}{\partial u}\otimes \left(\mathbf{b}\times \mathbf{R}\right)+
//          *		\mathbf{R}\otimes\left(\frac{\partial \mathbf{r}}{\partial u}\times\mathbf{b}\right)+
//          *		\frac{1}{2} \left[ \left(\mathbf{R}\times\mathbf{b}\right)\cdot \frac{\partial \mathbf{r}}{\partial u} \right]\left[\mathbf{I}\left(1+\frac{3a^2}{R_a^2}\right)+\frac{3}{R_a^2}\mathbf{R}\otimes\mathbf{R}\right]
//          *	\f]
//          *  where \f$R_a^2=|\mathbf{R}|^2+a^2\f$ is the modified squared norm of \f$\mathbf{R}\f$.
//          *
//          *	The return value is asymmetric and dimensionless in the sense that the actual stress integrand is:
//          *	\f[
//          *		d\mathbf{\sigma}=\frac{\mu}{4\pi (1-\nu)}\left(d\mathbf{s}+d\mathbf{s}^T\right)
//          *	\f]
//          */
//			VectorDimD R(Rfield-P);
//			double RaSquared (R.squaredNorm() + a2);
//			MatrixDim temp(   (Material<Isotropic>::C1*(1.0+1.5*a2/RaSquared)*T*(B.cross(R)).transpose()
//                               + 	R*(T.cross(B)).transpose()
//                               +   0.5* R.cross(B).dot(T) * (I*(1.0+3.0*a2/RaSquared) + 3.0/RaSquared*R*R.transpose())
//                               )/std::pow(RaSquared,1.5)*quadWeight);
//			
//			return Material<Isotropic>::C2*(temp+temp.transpose());
//		}
//		
//        
//        
//		
//		/********************************************************/
//		MatrixDim stress() const
//        {/*! The total stress field on this DislocationParticle
//			 */
//            //            MatrixDim temp(MatrixDim::Zero());
//            //            for (typename CellMapType::const_iterator nearCellIter=this->nearCellsBegin();nearCellIter!=this->nearCellsEnd();++nearCellIter){
//            //                for (typename ParticleContainerType::const_iterator partIter=nearCellIter->second->particleBegin();partIter!=nearCellIter->second->particleEnd();++partIter){
//            //                    temp+=(*partIter)->stress_at(P);
//            //                }
//            //            }
//            //            if(useMultipoleStress){
//            //                for (typename CellMapType::const_iterator farCellIter=this->farCellsBegin();farCellIter!=this->farCellsEnd();++farCellIter){
//            //                    temp+= farCellIter->second->multipoleStress(P);
//            //                }
//            //            }
//            
//            MatrixDim temp(MatrixDim::Zero());
//            for (typename CellMapType::const_iterator neighCellIter=this->neighborCellsBegin();neighCellIter!=this->neighborCellsEnd();++neighCellIter){
//                for (typename ParticleContainerType::const_iterator partIter=neighCellIter->second->particleBegin();partIter!=neighCellIter->second->particleEnd();++partIter){
//                    temp+=(*partIter)->stress_at(P);
//                }
//            }
//            
//            
//            switch (nearCellStressApproximation)
//            {
//                case FULL: // quadrature-quadrature
//                    // finish here
//                    assert(0 && "FINISH HERE");
//                    break;
//                case CELL_PARTICLE: // cell-quadrature
//                    for (typename CellMapType::const_iterator nearCellIter=this->nearCellsBegin();nearCellIter!=this->nearCellsEnd();++nearCellIter){
//                        temp+= nearCellIter->second->multipoleStress(P);
//                    }
//                    break;
//                case CELL_CELL: // cell-cell
//                    //temp+= this->pCell->nearStress;
//                    temp+= this->pCell->nearStress;
//                    break;
//                    
//                default: // no computation
//                    break;
//            }
//            
//            
//            switch (farCellStressApproximation)
//            {
//                case FULL: // quadrature-quadrature
//                    // finish here
//                    assert(0 && "FINISH HERE");
//                    break;
//                case CELL_PARTICLE: // cell-quadrature
//                    for (typename CellMapType::const_iterator farCellIter=this->farCellsBegin();farCellIter!=this->farCellsEnd();++farCellIter){
//                        temp+= farCellIter->second->multipoleStress(P);
//                    }
//                    break;
//                case CELL_CELL: // cell-cell
//                    //temp+= this->pCell->farStress;
//                    temp+= this->pCell->farStress;
//                    break;
//                    
//                default: // no computation
//                    break;
//            }
//            
//            
//#ifdef UserStressFile
//            //			temp+=userStress(k);
//#endif
//            
//			return temp;
//		}
//		
//		/********************************************************/
//		MatrixDim stress(const MatrixDim& sourceBvpStress, const MatrixDim& sinkBvpStress) const {
//			/*! The total stress field on this DislocationParticle
//			 */
//            MatrixDim temp(stress());
//			temp+=sourceBvpStress*(1.0-quadAbscissa)+sinkBvpStress*quadAbscissa;
//			return temp;
//		}
		
	};
    
//    // Static data members
//	template <short unsigned int dim>
//    double DislocationParticle<dim>::a2=1.0;  // square of core size a
//    
//	template <short unsigned int dim>
//	const Eigen::Matrix<double,dim,dim> DislocationParticle<dim>::I=Eigen::Matrix<double,dim,dim>::Identity();  // square of core size a
//        
//    template <short unsigned int dim>
//    int DislocationParticle<dim>::nearCellStressApproximation=3;  // square of core size a
//    
//    template <short unsigned int dim>
//    int DislocationParticle<dim>::farCellStressApproximation=3;  // square of core size a
    
    
    /**************************************************************************/
    /**************************************************************************/
}	// close namespace
#endif
