/* This file is part of MODEL, the Mechanics Of Defect Evolution Library.
 *
 * Copyright (C) 2011 by Giacomo Po <gpo@ucla.edu>.
 *
 * model is distributed without any warranty under the 
 * GNU General Public License (GPL) v2 <http://www.gnu.org/licenses/>.
 */

#ifndef model_MULTIPOLEEXPANSION_H_
#define model_MULTIPOLEEXPANSION_H_

#include <model/DislocationDynamics/Materials/Material.h>
#include <Eigen/Dense>

namespace model {	
	
	template <int dim>
    struct MultipoleExpansion {
		
        typedef Eigen::Matrix<double,dim,1>    VectorDimD;
        typedef Eigen::Matrix<int,dim,1>       VectorDimI;
        typedef Eigen::Matrix<double,dim,dim>  MatrixDimD;	// remove this with Dislocation Stuff
        
        
	public:
		
        static const MatrixDimD I;
        
        
        /* axialVector ******************************************/
        static VectorDimD axialVector(const MatrixDimD& M){
            return (VectorDimD()<< M(1,2)-M(2,1), M(2,0)-M(0,2), M(0,1)-M(1,0) ).finished();
        }
        
        /* skewMatrix ******************************************/
        static MatrixDimD skewMatrix(const VectorDimD& v){
            return (MatrixDimD()<<  0.0,  v(2), -v(1), 
                    /*         */ -v(2),   0.0,  v(0),
                    /*         */  v(1), -v(0),   0.0).finished();
        }
        
        /* multipoleStress *************************************/
        static MatrixDimD multipoleStress(const VectorDimD& Rfield, const MatrixDimD& alpha, const VectorDimD& R0){
            /*! The stress field generated by the dislocation lines in this cell at Rfield,
             *  computed with the multipole expansion method (Wang, Z., Ghoniem, N. M., & LeSar, R. (2004). Multipole representation of the elastic field of dislocation ensembles. Physical Review B).
			 * @param[in] Rfield	the field point
			 *
			 * The return value is calculated according to:
			 *	\f[
			 *		\sigma_{ij}=\frac{\mu}{8\pi}\left\{
             *                    R_{,mpp}\left(\epsilon_{jmn}\alpha_{ni}+\epsilon_{imn}\alpha_{nj}\right)
             *                      +\frac{2}{1-\nu}\left[\epsilon_{nkm}\alpha_{nk}R_{,ijm}
             *                      -\delta_{ij}R_{,mpp}\epsilon_{nkm}\alpha_{nk}\right]
             *                   \right\}
			 *	\f]
             * where \f$\mathbf{R}=\mathbf{R}_{field}-\mathbf{R}_0\f$ and \f$\mathbf{R}_0\f$ is the center of the current cell.
             * Expanding the derivatives of R:
             *	\f[
			 *		\sigma_{ij}=\frac{\mu}{8\pi R^3}\left\{
             *                    -2\left(\underbrace{\epsilon_{njm}R_m}_{S_{nj}}\alpha_{ni}+\underbrace{\epsilon_{nim}R_m}_{S_{ni}}\alpha_{nj}\right)
             *                      +\frac{2}{1-\nu}\left[\underbrace{\epsilon_{nkm}\alpha_{nk}}_{a_m}\left(-\delta_{jm}R_i-\delta_{im}R_j-\delta_{ij}R_m+\frac{3R_iR_jR_m}{R^2}\right)
             *                      +2\delta_{ij}\underbrace{\epsilon_{nkm}\alpha_{nk}}_{a_{m}}R_{m}\right]
             *                   \right\}
			 *	\f]
             *  In vector form:
             *	\f[
			 *		\mathbf{\sigma}=\frac{\mu}{4\pi R^3}\left\{
             *                    -\left(\mathbf{\alpha}^T\mathbf{S}+\mathbf{S}^T\mathbf{\alpha}\right)
             *                      +\frac{1}{1-\nu}\left[-\mathbf{R}\otimes\mathbf{a}-\mathbf{a}\otimes\mathbf{R}+\mathbf{I}\left(\mathbf{R}\cdot\mathbf{a}\right)+\frac{3\mathbf{R}\otimes\mathbf{R}\left(\mathbf{R}\cdot\mathbf{a}\right)}{R^2}
             *                      \right]
             *                   \right\}
			 *	\f]
			 *	where: \f$S_{nj}=\epsilon_{njm}R_m\f$ is the skew-symmetric matrix associated with the vector \f$R_m\f$, while \f$a_m=\epsilon_{nkm}\alpha_{nk}\f$ is the axial vector associated with the
             *  skew-symmetric part of \f$\mathbf{\alpha}\f$.
             *
             *  If we let:
             *	\f[
			 *		\mathbf{\sigma}*=
             *                    -\mathbf{\alpha}^T\mathbf{S}
             *                      +\frac{1}{1-\nu}\left[-\mathbf{R}\otimes\mathbf{a}+\frac{1}{2}\mathbf{I}\left(\mathbf{R}\cdot\mathbf{a}\right)+\frac{3\mathbf{R}\otimes\mathbf{R}\left(\mathbf{R}\cdot\mathbf{a}\right)}{2R^2}
             *                      \right]
			 *	\f]
             * Then:
             *	\f[
			 *		\mathbf{\sigma}*=\frac{\mu}{4\pi R^3}\left(\mathbf{\sigma}*+\mathbf{\sigma}*^T\right)
			 *	\f]
			 */
            const VectorDimD R(Rfield- R0);
            const double R2(R.squaredNorm());
            const double R3(std::pow(sqrt(R2),3));
            const VectorDimD a(axialVector(alpha));
            const MatrixDimD S(skewMatrix(R));
            const MatrixDimD temp( -alpha.transpose()*S+1.0/(1.0-Material<Isotropic>::nu)*(-R*a.transpose()+0.5*I*(R.dot(a))+1.5*R*R.transpose()*R.dot(a)/R2) );
            
            return Material<Isotropic>::mu/(4.0*M_PI*R3)*( temp+temp.transpose() );
        }
		
	};
    
    // Declare static data members
    template <int dim>
    const Eigen::Matrix<double,dim,dim> MultipoleExpansion<dim>::I=Eigen::Matrix<double,dim,dim>::Identity();
	
	////////////////////////////////////////////////////////////////////////////////
}	// close namespace model
#endif

