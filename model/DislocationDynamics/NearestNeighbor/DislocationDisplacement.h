/* This file is part of MODEL, the Mechanics Of Defect Evolution Library.
 *
 * Copyright (C) 2011 by Giacomo Po <gpo@ucla.edu>.
 *
 * model is distributed without any warranty under the
 * GNU General Public License (GPL) v2 <http://www.gnu.org/licenses/>.
 */

#ifndef _model_DislocationDisplacement_h_
#define _model_DislocationDisplacement_h_

#include <model/ParticleInteraction/FieldBase.h>


namespace model
{
	
	/**************************************************************************/
	/**************************************************************************/
	template<short unsigned int _dim>
	struct DislocationDisplacement
    /* inheritance */ : public FieldBase<double,_dim,1>
    {
        
        typedef DislocationDisplacement<_dim> DislocationDisplacementType;
        typedef FieldBase<double,_dim,1> FieldBaseType;
        typedef typename FieldBaseType::MatrixType MatrixType;
        
        static  double a2;
		static const Eigen::Matrix<double,_dim,_dim> I;

#if _MODEL_NON_SINGULAR_DD_ == 0 // Note that if _MODEL_NON_SINGULAR_DD_ is not #defined, the preprocessor treats it as having the value 0.
        
        template <typename DislocationParticleType, typename OtherParticleType>
        static MatrixType compute(const DislocationParticleType& source,const OtherParticleType& field)
        {
            
            /*!@param[in] Rfield	the field point
             * @param[in] S the unit vector necessary to compute displacement as line integral
             * \returns The infinitesimal dispacement field generated by this segment at a field point
             *
             * The return value is calculated according to:
             *	\f[
             *		\mathbf{u}^*(\alpha_k,\mathbf{r}_f) = \frac{1}{R}\left\{ \frac{2(1-\nu)}{R+\mathbf{R}\cdot\mathbf{S}}\mathbf{b} \left[\left(\mathbf{S}\times\mathbf{R}\right)\cdot\frac{d\mathbf{r}_s}{d\alpha}\right]
             *                                          + (1-2\nu)\left( \mathbf{b}\times \frac{d\mathbf{r}_s}{d\alpha}\right)
             *                                          +\frac{1}{R^2}\left[\left(\frac{d\mathbf{r}_s}{d\alpha}\times\mathbf{b}\right)\cdot\mathbf{R}\right]\mathbf{R} \right\}
             *	\f]
             *	where:
             *  - \f$\mathbf{r}(\alpha)\f$ is the parametrized source line segment;
             *  - \f$\mathbf{R}(\mathbf{r}_f,\alpha) = \mathbf{r}_f-\mathbf{r}_s(\alpha)\f$ is vector connecting the source point to the field point.
             *
             *  The calculation of the solid angle is performed transforming the surface integral into a line integral. From Stokes theorem:
             *	\f[
             *  \oint\frac{\hat{\mathbf{S}}\times\mathbf{R}}{R(R-\mathbf{S}\cdot\mathbf{R})}\cdot d\mathbf{l}
             *  \underbrace{=}_{\mbox{Stokes Th.}}\int\left(\nabla\times\frac{\hat{\mathbf{S}}\times\mathbf{R}}{R(R-\mathbf{S}\cdot\mathbf{R})}\right)\cdot\hat{\mathbf{n}}dA
             *  \underbrace{=}_{\mbox{identity}}
             * -\int\frac{\mathbf{R}}{R^3}\cdot\mathbf{n}dA
             *	\f]
             * References:
             * [1] Asvestas, J. Line integrals and physical optics. Part I. The transformation of the solid-angle surface integral to a line integral. J. Opt. Soc. Am. A, 2(6), 891â€“895.
             *
             * \f[
             * \begin{align}
             * \mathbf u(\mathbf x)
             * &=-\frac{\mathbf b\Omega^0}{4\pi}+\frac{1}{8\pi(1-\nu)}\oint_\mathcal{L}&\frac{1}{R}\left\{
             * \underbrace{(1-2\nu)}_{C_3} \hat{\mathbf \xi}'\times \mathbf b
             * +\left[\hat{\mathbf R}\cdot\left(\hat{\mathbf \xi}' \times \mathbf b\right) \right]\hat{\mathbf R}  \right\} dL'
             * \end{align}
             * \f]
             *
             */
            
            INSTEAD OF S USE field.outNormal
			
			const VectorDim R(field.P-source.P);
            const double RaSquared(R.squaredNorm()+a2);
			const double Ra=sqrt(RaSquared);
			return 1.0/Ra * (+ 2.0*Material<Isotropic>::C1/(Ra+R.dot(S))*source.B*(S.cross(R)).dot(source.T)
                             /*            */ + Material<Isotropic>::C3*source.T.cross(source.B)
                             /*            */ + 1.0/RaSquared*(source.T.cross(source.B)).dot(R)*R
                             /*            */ );
			
        }
        
#elif _MODEL_NON_SINGULAR_DD_ == 1 /* Cai's non-singular theory */
        
        static_assert(0,"THE LINE-INTEGRAL REPRESENTATION OF THE SOLID ANGLE FOR CAI'S THEORY HAS NOT BEEN IMPLEMENTED");

        
#elif _MODEL_NON_SINGULAR_DD_ == 2 /* Lazar's non-singular theory */
        
        static_assert(0,"THE LINE-INTEGRAL REPRESENTATION OF THE SOLID ANGLE FOR LAZAR'S THEORY HAS NOT BEEN IMPLEMENTED");
        
#else
#error Unsupported choice of field regularization
#endif
        
		
	};
    
    // Static data members
	template<short unsigned int _dim>
    double DislocationDisplacement<_dim>::a2=1.0;  // square of core size a
    
	template<short unsigned int _dim>
	const Eigen::Matrix<double,_dim,_dim> DislocationDisplacement<_dim>::I=Eigen::Matrix<double,_dim,_dim>::Identity();  // square of core size a

    
    /**************************************************************************/
    /**************************************************************************/
}	// close namespace
#endif
