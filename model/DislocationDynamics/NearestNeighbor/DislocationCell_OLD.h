/* This file is part of MODEL, the Mechanics Of Defect Evolution Library.
 *
 * Copyright (C) 2011 by Giacomo Po <gpo@ucla.edu>.
 *
 * model is distributed without any warranty under the 
 * GNU General Public License (GPL) v2 <http://www.gnu.org/licenses/>.
 */

#ifndef _model_DislocationCell_h_
#define _model_DislocationCell_h_

#include <Eigen/Dense>
#include <model/SpaceDecomposition/SpatialCell.h>
#include <model/DislocationDynamics/Materials/Material.h>
#include <model/DislocationDynamics/NearestNeighbor/MultipoleExpansion.h>
#include <model/Utilities/TypeTraits.h>

namespace model {	
	   
    /**************************************************************************/
	/* TRAITS *****************************************************************/
	template<short unsigned int dim>
	struct DislocationQuadratureParticle;

	template<short unsigned int dim>
	struct DislocationCell;
    
    template<>
	struct TypeTraits<DislocationQuadratureParticle<3> >
    {
        //enum {dim=3;}
        typedef DislocationQuadratureParticle<3> ParticleType;
        typedef               DislocationCell<3> CellType;
    };

    template<>
	struct TypeTraits<DislocationCell<3> >
    {
        typedef DislocationQuadratureParticle<3> ParticleType;
        typedef               DislocationCell<3> CellType;
    };
    
    
	/********************************************************************************************/
	/********************************************************************************************/
	/*! \brief A dim-dimensional cell occupying the spatial region cellID<= x/cellSize < (cellID+1). 
	 *  DislocationCell is aware off all ParticleType objects present inside it. 
	 */
	template<short unsigned int dim>
	struct DislocationCell : public SpatialCell<DislocationCell<dim>,dim>{
		
        typedef typename TypeTraits<DislocationCell<dim> >::ParticleType ParticleType;
		typedef SpatialCell<DislocationCell<dim>,dim> Base;
        typedef typename Base::CellMapType CellMapType;
        typedef typename Base::CellIdType CellIdType;
        typedef typename Base::VectorDimD VectorDimD;
        
        typedef Eigen::Matrix<double,dim,dim>  MatrixDimD;	
        MatrixDimD alpha;	// the dislocation density tensor 
        MatrixDimD nearStress;	// the stress field generated by near cells at the center of this
        MatrixDimD  farStress;	// the stress field generated by  far cells at the center of this
        
	public:
        
			
		/* Constructor *******************************************/
		DislocationCell(const CellIdType& cellID_in) :
        /* Base constructor */ Base::SpatialCell(cellID_in),
        /* init list        */ alpha(MatrixDimD::Zero()),
        /* init list        */ nearStress(MatrixDimD::Zero()),
        /* init list        */  farStress(MatrixDimD::Zero())
        {/*! Constructor initializes alpha, nearStress, and farStress to zero.
          */
        }
		
		
        /* multipoleStress ****************************************/
        MatrixDimD multipoleStress(const VectorDimD& rField) const
        {/*! @param[in] rField The file dpoint
          *  \returns The stress field generated by this DislocationCell at rField
          *  computed using MultipoleExpansion.
          */
            return MultipoleExpansion<dim>::multipoleStress(rField,alpha,this->center);
        }
        
        
        /* computeCenterStress ************************************/
        void computeCenterStress()
        {
            if(ParticleType::nearCellStressApproximation==ParticleType::CELL_CELL){ // near stress is computed using cell-cell
                for (typename CellMapType::const_iterator nearCellIter=this->nearCellsBegin();nearCellIter!=this->nearCellsEnd();++nearCellIter){
                    nearStress+= nearCellIter->second->multipoleStress(this->center);
                }
            }
            if(ParticleType::farCellStressApproximation==ParticleType::CELL_CELL){ // far stress is computed using cell-cell
                for (typename CellMapType::const_iterator farCellIter=this->farCellsBegin();farCellIter!=this->farCellsEnd();++farCellIter){
                     farStress+= farCellIter->second->multipoleStress(this->center);
                }
            }
        }

	};
    
  	////////////////////////////////////////////////////////////////////////////////
}	// close namespace model
#endif

